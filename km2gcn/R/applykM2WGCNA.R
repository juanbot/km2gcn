

#' This is the main function of the package. It takes a hopefully correctly created WGCN network and,
#' based on gene expression it modifies the module color assignment by using k-means heuristic.
#' The description of the parameters show how the function works.
#' @param net.label This parameter is useful for referring to this specific network at any plot that
#' might be created to monitor the algorithm's behavior
#' @param net.file can be either a full path to a RDS object storing the network or the network itself.
#' We expect a list with objects "moduleColors" and "MEs". The "moduleColors" element si a named vector
#' whose elements are colors as assigned by WGCNA. The names() function should return the gene names for
#' each vector's element. The "MEs" is a matrix with a column for each module and a row for each sample.
#' It contains the module eigengenes. Note that the order of genes in moduleColors is the same as they
#' appear in columns in expr.data parameter's object.
#' @param expr.data is, again, a full path file name or a data frame with genes in columns and samples in
#' rows, giving the expression data used to construct the WGCNA network. The function expects genes in the
#' column order to correspond to the order of nameColors of net.file param.
#' @param  beta The soft threshold parameter as it was used with WGCNA
#' @param n.iterations A max number of iterations to run the k-means
#' @param meg Minimum number of genes exchanged: if before the number of iterations, the number of genes exchanged
#' in the current iteration is less than this parameter, the algorithm stops.
#' @param job.path Where to store the files generated by the function
#' @param tom.matrix If the TOM is precalculated, it can be pased as full path file name or as an object.
#' @param plot.evolution If TRUE, it will generate a full set of plots that help making a proper diagnose of
#' the function.
#' @param plot.go If plot.evolution is TRUE and this is also TRUE, it will include in the evolution plot an
#' evaluation of the GO (GEne Ontology) signals obtained from the new partition, in comparision with the
#' original partition obtained by the standard WGCNA
#' @param debug It can be used to set a small number of genes just to run the fuction tentatively before using
#' the whole gene set. May be useful to get a flavour on how the method works.
#' @param net.type it is used in the same sense as WGCNA
#' @param final.net where to store as an RDS object the final network obtained
#' @param min.genes.for.grey The number of genes to consider grey genes as part of the optimization
#' @return The network, post-processed with a k-means heuristic
#' @export
applykM2WGCNA <- function(net.label,
                          net.file,
                          expr.data,
                          beta=6,
                          n.iterations=20,
                          meg = 20,
                          job.path,
                          tom.matrix=NULL,
                          plot.evolution=TRUE,
                          plot.go=plot.evolution,
                          debug=NULL,
                          net.type="signed",
                          final.net=paste0(job.path,"/",net.label,".",beta,".",net.type,".it.",n.iterations,".rds"),
                          min.genes.for.grey=20){

  if(typeof(expr.data) == "character")
    expr.data <- readRDS(expr.data)

  if(!is.null(debug)){
    cat("We are debugging, using only ",debug,"genes from gene expression\n")
    expr.data = expr.data[,1:as.numeric(debug)]
  }
  cat("Working with",nrow(expr.data),"samples and",ncol(expr.data),"genes\n")

  #Step 2
  if(typeof(net.file) == "character"){
    print("Loading network")
    net <- readRDS(net.file)
  }else
    net = net.file

  if(!is.null(debug)){
    cat("We are debugging, using only ",debug,"genes from the source GCN\n")
    net$moduleColors = net$moduleColors[1:as.numeric(debug)]
    mods = unique(net$moduleColors)

    #Get rid of the MEs not found in mods
    mods = paste0("ME",mods)
    net$MEs = net$MEs[,colnames(net$MEs) %in% mods]
  }
  cat("The network includes",length(net$moduleColors),"genes and ",
      length(unique(net$moduleColors)),"modules\n")

  if(plot.evolution){
    plot.evolution.file <- paste0(final.net,".evkM.pdf")
    cat("Evolution will be plotted at",plot.evolution.file,"\n")
    if(plot.go){
      go.file <- paste0(final.net,".gokM.rds")
      print(paste0("GO analysis will be at  ",go.file))
    }else
      go.file = NULL
  }

  partitions.file <- paste0(final.net,".parts.rds")
  cat("Partitions data will be at",partitions.file,"\n")


  #ALGORITHM SPECIFICATION
  #Step 1. Let D be the expression data in which dij in D represents the expression value for
  #sample i and gene j, being s samples and g genes in total.
  #Step 2. Construct the partition by the WGCNA process, let P_D={m_1, m_2, ..., m_n} be
  #that partition where m_k is the k-th module.
  #Step 3. Get the eigengenes for each module within the partition, E={e_1, e_2, ..., e_n}
  #Step 4. Set up the k-means clustering
  #Step 4.1. Set k to n
  #Step 4.2. Set the centroids C to the eigengenes E, thus C to E
  #Step 5. Run the algorithm and monitor its evolution
  #Step 5.1 Set iterations to 0
  #Step 5.2 Create a new partition P', given C with n modules such that, for each gene, 1 <=
  #		j <= g, g_j belongs to the module c_t in C such that a distance meassure d(g_j,c_t) is
  #		minimum.
  #		Step 5.3 Calculate eigengenes of P', giving a new E'
  #		Step 5.4 Evaluate the progress. If progress done, set iterations to iterations + 1 and
  #		C to E' and go to step 5.2
  #Step 5.5 Finish
  #

  #Gather the current partition we start from
  partition.in.colors <- net$moduleColors
  #print(head(partition.in.colors,5))

  print("Getting initial eigengenes")
  if(sum(partition.in.colors == "grey") < min.genes.for.grey)
    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)
  else
    eigengenes = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)

  cat("We got",length(eigengenes$eigengenes)," eigengene vectors\n")
  print(head(eigengenes$eigengenes))

  #This variable is fixed and used as a reference to indicate the
  #modules used (they are colours but the position within the vector is
  #also relevant)
  centroid.labels <- substring(names(eigengenes$eigengenes),3)
  print("Module colors are")
  print(head(centroid.labels))

  k <- length(eigengenes$eigengenes)
  #Centroids must be a matrix with as much colums as centroids,
  #as much rows as samples
  centroids <- createCentroidMatrix(eigengenes$eigengenes)


  print("We have generated centroids")
  print(head(centroids))


  #Step 5
  #For storage of all the partitions created during the iterations
  partitions <- list()
  #A partition will be a list of as much elements as genes and for the
  #i-th position it stores the index of the module the ith gene belongs
  #to, and the color can be found in "centroid.labels"
  print("From partition ")
  print(head(partition.in.colors))
  print("We create ")
  new.partition <- match(partition.in.colors, centroid.labels)
  print(head(new.partition))
  names(new.partition) <- centroid.labels[new.partition]
  partitions[[1]] <- new.partition


  #Launch the iterations
  exchanged.genes = meg + 1
  iteration = 1

  while(exchanged.genes > meg & iteration <= n.iterations){

    #for(iteration in 1:n.iterations){
    print(paste0("Starting partition ",iteration))
    print(paste0("Number of centroids before getting new partition ",ncol(centroids)))

    new.partition <- apply(expr.data,MARGIN=2,getBestModuleCor,centroids=centroids,
                           signed=(net.type == "signed"))

    partitions[[iteration + 1]] <- new.partition
    #Get the control values for the new partition
    exchanged.gene.count <- length(getExchangedGenes(partitions[[iteration]],
                                                     partitions[[iteration + 1]]))
    cat("A total of ", exchanged.gene.count,
        " genes moved to another partition\n")

    new.partition.in.colors <- centroid.labels[unlist(new.partition)]
    centroids <- getNewCentroids(expr.data,new.partition.in.colors,centroid.labels,min.genes.for.grey)

    exchanged.genes = exchanged.gene.count
    iteration = iteration + 1
  }
  cat("We finish with",iteration,"iterations\n")
  cat("Last number of gene changes where",exchanged.genes,"\n")
  saveRDS(partitions,partitions.file)

  if(plot.evolution)
    plotEvolution(net.label=net.label,
                  net=net,
                  tom=tom.matrix,
                  beta=beta,
                  expr.data=expr.data,
                  net.type=net.type,
                  module.colors=centroid.labels,
                  partitions=partitions,
                  plot.evolution.file=plot.evolution.file,
                  go.file=go.file)

  print("The algorithm finished correctly")
  return(genNetFromPartition(expr.data.file=expr.data,
                             beta=beta,
                             partitions.file=partitions.file,
                             mgg=min.genes.for.grey,index=-1))
}






createCentroidMatrix <- function(eigengenes){
  my.matrix <- NULL
  for(eigengene in eigengenes){
    my.matrix <- cbind(my.matrix,eigengene)
  }
  return(my.matrix)
}




getNewCentroids <- function(expr.data,partition.in.colors,centroid.labels,mgg){
  if(sum(partition.in.colors == "grey") < mgg)
    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=TRUE)$eigengenes
  else
    eg.vectors = moduleEigengenes(expr.data,partition.in.colors, excludeGrey=F)$eigengenes

  names(eg.vectors) <- substring(names(eg.vectors),3)
  eg.vectors <- eg.vectors[,centroid.labels]
  return(eg.vectors)
}

getExchangedGenes <- function(old.partition,new.partition){
  stopifnot(length(old.partition) == length(new.partition))
  return(old.partition[old.partition != new.partition])
}


